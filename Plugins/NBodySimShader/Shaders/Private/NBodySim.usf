#include "/Engine/Private/Common.ush"

// Buffers
StructuredBuffer<float> Masses;
RWStructuredBuffer<float> alphaS;
RWStructuredBuffer<float3> Positions;
RWStructuredBuffer<float3> Velocities;


//
StructuredBuffer<int> LinkOffsets;
StructuredBuffer<int> LinkCounts;
StructuredBuffer<int> LinkIndices;
StructuredBuffer<float> LinkStrengths;
StructuredBuffer<float> LinkBiases;
StructuredBuffer<float> Linkinout;



const uint NumLinks;

const uint shaderdebug;


// Settings
const uint NumBodies;
const float GravityConstant;
const float CameraAspectRatio;
const float ViewportWidth;
const float DeltaTime;
const float alpha;

float3 CalculateGravitationalForce(uint TargetBodyID, uint AffectingBodyID, float alpha)
{
	
	float3 dir = Positions[AffectingBodyID] - Positions[TargetBodyID];
	
	float d = distance(Positions[TargetBodyID], Positions[AffectingBodyID]);

	float l = d * d;
	float distancemin1 = 1;
	if (l < distancemin1)
	{
		l = sqrt(distancemin1 * l);
	}
	
	float ForceMagnitude= -60;
	
	return dir * ForceMagnitude * alpha /l;
}

float wasteTime() {
	float sum = 0.0;
	int i, j;

	// Using a very large number of iterations to waste time
	for (i = 0; i < 100000; i++) {
		for (j = 0; j < 100000; j++) {
			sum += 1; // Adding trigonometric computation to increase loop execution time
		}
	}
    
	return sum; // Returning sum to prevent the compiler from optimizing the loop away
}


[numthreads(256, 1, 1)]
void CalculateVelocitiesCS(uint3 ID : SV_DispatchThreadID)
{
	if (ID.x >= NumBodies) return;

	if (shaderdebug == 0)
	{
		float alphaS1;

		if (0)
		{
			alphaS[ID.x] += (0-alphaS[ID.x]) * 0.022763;
			alphaS1 = alphaS[ID.x];
		}
		else
		{
			alphaS[ID.x] = alpha;
			alphaS1 = alpha;
		}
		
		float3 Acceleration= float3(0, 0, 0);
		
		// Calculate link force
		int offset = LinkOffsets[ID.x];
		int count = LinkCounts[ID.x];
		for (int i = offset;
			i < offset + count;
			i++)
		{
			int affectingBodyID = LinkIndices[i];
			int Linkinout1 = Linkinout[i];


			float3 new_v;
			if (Linkinout1 == 1)
			{
				new_v = Positions[affectingBodyID] + Velocities[affectingBodyID] - Positions[ID.x] - Velocities[ID.x];
			}else
			{
				new_v = Positions[ID.x] + Velocities[ID.x] - Positions[affectingBodyID] - Velocities[affectingBodyID];
			}
			
			float l = length(new_v);
			l = (l - 30) /
				l * alphaS1 * LinkStrengths[i];
			new_v *= l;
			
			if (Linkinout1 == 1)
			{
				Acceleration += new_v * (1 - LinkBiases[i]);
			}
			else
			{
				Acceleration -= new_v * (LinkBiases[i]);
			}

		}
		
		// Calculate gravitational force
		for (uint i = 0; i < NumBodies; i++)
		{
			// Skip if self.
			if (i == ID.x) continue;
			float3 GravityForce = CalculateGravitationalForce(ID.x, i,alphaS1);
			Acceleration += GravityForce;
			
		}
		
		Velocities[ID.x] += Acceleration;
		const float velocityDecay = 0.6;
		Velocities[ID.x] *= velocityDecay;
		Positions[ID.x] += Velocities[ID.x];
	}
	else {
		float s=wasteTime();


		if (ID.x==0)
		{
			alphaS[ID.x] = s;
		}else
		{
			alphaS[ID.x] = alpha;

		}


		
		// alphaS[ID.x] += (0-alphaS[ID.x]) * 0.022763;


		
		float3 pos = Positions[ID.x];  // Read the current position
		pos += float3(1.0, 1.0,1.0);  // Increment each component by 1
		Positions[ID.x] = pos;  // Write it back to the buffer
		
	}

}


