#include "/Engine/Private/Common.ush"

// Buffers
StructuredBuffer<float> Masses;
RWStructuredBuffer<float> alphaS;
RWStructuredBuffer<float3> Positions;
RWStructuredBuffer<float3> Velocities;


//
StructuredBuffer<int> LinkOffsets;
StructuredBuffer<int> LinkCounts;
StructuredBuffer<int> LinkIndices;
StructuredBuffer<float> LinkStrengths;
StructuredBuffer<float> LinkBiases;
StructuredBuffer<float> Linkinout;



const uint NumLinks;

const uint shaderdebug;


// Settings
const uint NumBodies;
const float GravityConstant;
const float CameraAspectRatio;
const float ViewportWidth;
const float DeltaTime;
const float alpha;

float3 CalculateGravitationalForce(uint TargetBodyID, uint AffectingBodyID, float alpha333)
{
	
	float3 dir = Positions[AffectingBodyID] - Positions[TargetBodyID];
	
	float d = distance(Positions[TargetBodyID], Positions[AffectingBodyID]);

	float l = d * d;
	float distancemin1 = 1;
	if (l < distancemin1)
	{
		l = sqrt(distancemin1 * l);
	}
	
	float ForceMagnitude= -60;
	
	return dir * ForceMagnitude * alpha333 /l;
}

float wasteTime() {
	float sum = 0.0;
	int i, j;

	// Using a very large number of iterations to waste time
	for (i = 0; i < 100000; i++) {
		for (j = 0; j < 100000; j++) {
			sum += 1; // Adding trigonometric computation to increase loop execution time
		}
	}
    
	return sum; // Returning sum to prevent the compiler from optimizing the loop away
}


[numthreads(256, 1, 1)]
void CalculateVelocitiesCS(uint3 ID : SV_DispatchThreadID)
{
	if (ID.x >= NumBodies) return;

	if (shaderdebug < 10)
	{

		if(alpha>0.98)
		{
			return;
		}
		
		float alphaUUU;

		if (0)
		{
			alphaS[ID.x] += (0-alphaS[ID.x]) * 0.022763;
			alphaUUU = alphaS[ID.x];
		}
		else
		{
			
			if (ID.x==1)
			{
				if (abs(alpha-0.977)<0.001)
				{
					alphaS[ID.x] = 1;
				}
				else
				{
					alphaS[ID.x] += 1;
				}
			}
			else
			{
				alphaS[ID.x] = alpha;

			}
			alphaUUU = alpha;
		}
		
		float3 Acceleration= float3(0, 0, 0);
		
		bool calculateLinkForce;
		bool calculateGravityForce;

		if(shaderdebug==1)
		{
			calculateLinkForce = true;
			calculateGravityForce = false;
		}

		if(shaderdebug==2)
		{
			calculateLinkForce = false;
			calculateGravityForce = true;
		}

		if (shaderdebug==3)
		{
			calculateLinkForce = true;
			calculateGravityForce = true;
		}
		
		
		if (calculateLinkForce)
		{
			int offset = LinkOffsets[ID.x];
			int count = LinkCounts[ID.x];
			for (int i = offset;
			     i < offset + count;
			     i++)
			{
				int affectingBodyID = LinkIndices[i];
				int Linkinout1 = Linkinout[i];


				float3 new_v;
				if (Linkinout1 == 1)
				{
					new_v = Positions[affectingBodyID] + Velocities[affectingBodyID] - Positions[ID.x] - Velocities[ID.x];
				}else
				{
					new_v = Positions[ID.x] + Velocities[ID.x] - Positions[affectingBodyID] - Velocities[affectingBodyID];
				}


				////////////////////////////////////////////////////////////////
				// if(ID.x==0)
				// {
				// 	Positions[0]=Positions[ID.x];
				//
				// 	alphaS[ID.x] = new_v.x;
				// 	return;
				// }else
				// {
				// 	return;
				// }
				//
				///////////////////////////////////////////////////////////////
			
				float l = length(new_v);
				l = (l - 30) /
					l * alphaUUU * LinkStrengths[i];
				new_v *= l;
			
				if (Linkinout1 == 1)
				{
					Acceleration += new_v * (1 - LinkBiases[i]);
				}
				else
				{
					Acceleration -= new_v * (LinkBiases[i]);
				}
			}
		}
		
		// Calculate gravitational force
		if (calculateGravityForce)
		{
			for (uint i = 0; i < NumBodies; i++)
			{
				// Skip if self.
				if (i == ID.x) continue;
				float3 GravityForce = CalculateGravitationalForce(ID.x, i,alphaUUU);
				Acceleration += GravityForce;
			}
		}
		
		Velocities[ID.x] += Acceleration;
		const float velocityDecay = 0.6;
		Velocities[ID.x] *= velocityDecay;
		Positions[ID.x] += Velocities[ID.x];
	}
	else {


		
		// float s=wasteTime();
		//
		//
		// if (ID.x==0)
		// {
		// 	alphaS[ID.x] = s;
		// }else
		// {
		// 	alphaS[ID.x] = alpha;
		//
		// }


		
		// Positions[ID.x] =Positions[ID.x];


		
		// float3 pos = Positions[ID.x];  // Read the current position
		// pos += float3(1.0, 1.0,1.0);  // Increment each component by 1
		// Positions[ID.x] = pos;  // Write it back to the buffer
		//
	}

}


